name: Sync upstream releases and publish release

on:
  workflow_dispatch:
  schedule:
    - cron: "0 14 * * 1"

permissions:
  contents: write

defaults:
  run:
    shell: bash

jobs:
  sync:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout (default branch)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure git
        run: |
          git config user.name vk-dynamic-sync-bot
          git config user.email actions@users.noreply.github.com

      - name: Fetch tags and branches
        run: |
          git fetch --tags --force --prune origin +refs/heads/*:refs/remotes/origin/*

      - name: Determine default branch name
        id: def
        run: |
          set -euo pipefail
          echo "default_branch=${{ github.event.repository.default_branch }}" >> "$GITHUB_OUTPUT"

      - name: Get last local release tag (vVK-GL)
        id: local
        run: |
          set -euo pipefail
          last_tag=$(git tag -l 'v*' --sort=-v:refname | head -n 1 || true)
          echo "last_tag=$last_tag" >> "$GITHUB_OUTPUT"

          last_vk=""
          last_gl=""
          if [ -n "$last_tag" ] && echo "$last_tag" | grep -Eq '^v[0-9]+\.[0-9]+\.[0-9]+-[0-9]+\.[0-9]+\.[0-9]+$'; then
            last_vk="$(echo "$last_tag" | sed -E 's/^v([0-9]+\.[0-9]+\.[0-9]+)-([0-9]+\.[0-9]+\.[0-9]+)$/\1/')"
            last_gl="$(echo "$last_tag" | sed -E 's/^v([0-9]+\.[0-9]+\.[0-9]+)-([0-9]+\.[0-9]+\.[0-9]+)$/\2/')"
          fi

          echo "last_vk=$last_vk" >> "$GITHUB_OUTPUT"
          echo "last_gl=$last_gl" >> "$GITHUB_OUTPUT"

      - name: Get latest upstream version-number tags
        id: upstream
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          get_latest_matching_tag() {
            local owner_repo="$1"
            local jq_filter="$2"
            gh api "repos/${owner_repo}/tags?per_page=100" --jq "$jq_filter"
          }

          vk_tag="$(get_latest_matching_tag \
            "KhronosGroup/Vulkan-Headers" \
            '[.[].name | select(test("^v[0-9]+\\.[0-9]+\\.[0-9]+$"))][0] // empty')"

          gl_tag="$(get_latest_matching_tag \
            "KhronosGroup/glslang" \
            '[.[].name | select(test("^v?[0-9]+\\.[0-9]+\\.[0-9]+$"))][0] // empty')"

          if [ -z "$vk_tag" ] || [ -z "$gl_tag" ]; then
            echo "Failed to find version-number tags"
            echo "Vulkan-Headers: $vk_tag"
            echo "glslang: $gl_tag"
            exit 1
          fi

          vk_ver="${vk_tag#v}"
          gl_ver="${gl_tag#v}"

          echo "vk_tag=$vk_tag" >> "$GITHUB_OUTPUT"
          echo "gl_tag=$gl_tag" >> "$GITHUB_OUTPUT"
          echo "vk_ver=$vk_ver" >> "$GITHUB_OUTPUT"
          echo "gl_ver=$gl_ver" >> "$GITHUB_OUTPUT"

      - name: Compute release ref vVK-GL
        id: plan
        run: |
          set -euo pipefail

          last_vk="${{ steps.local.outputs.last_vk }}"
          last_gl="${{ steps.local.outputs.last_gl }}"

          up_vk="${{ steps.upstream.outputs.vk_ver }}"
          up_gl="${{ steps.upstream.outputs.gl_ver }}"

          use_vk="$up_vk"
          use_gl="$up_gl"

          if [ -z "$use_vk" ]; then use_vk="$last_vk"; fi
          if [ -z "$use_gl" ]; then use_gl="$last_gl"; fi

          if [ -z "$use_vk" ] || [ -z "$use_gl" ]; then
            echo "Could not determine release versions"
            exit 1
          fi

          release_ref="v${use_vk}-${use_gl}"

          echo "use_vk=$use_vk" >> "$GITHUB_OUTPUT"
          echo "use_gl=$use_gl" >> "$GITHUB_OUTPUT"
          echo "release_ref=$release_ref" >> "$GITHUB_OUTPUT"

      - name: Check whether release branch exists on origin
        id: branchcheck
        run: |
          set -euo pipefail
          release_ref="${{ steps.plan.outputs.release_ref }}"
          if git ls-remote --heads origin "$release_ref" | grep -q .; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Helper - update CMake version variables idempotently
        run: |
          cat > .github_update_cmake.py <<'PY'
          import os, re, sys

          vk_ver = os.environ["VK_VER"]
          gl_ver = os.environ["GL_VER"]

          p = "CMakeLists.txt"
          try:
            txt = open(p, "r", encoding="utf-8").read()
          except FileNotFoundError:
            print("CMakeLists.txt not found")
            sys.exit(1)

          lines = txt.splitlines(True)

          rx_ver = re.compile(r'^\s*set\s*\(\s*VK_DYN_VER\b', re.IGNORECASE)
          rx_tag = re.compile(r'^\s*set\s*\(\s*VK_DYN_TAG\b', re.IGNORECASE)
          rx_min = re.compile(r'^\s*cmake_minimum_required\s*\(', re.IGNORECASE)

          set_ver = f'set(VK_DYN_VER "{vk_ver}" CACHE STRING "vk-dynamic project version")\n'
          set_tag = f'set(VK_DYN_TAG "v{vk_ver}-{gl_ver}" CACHE STRING "vk-dynamic release tag")\n'

          min_idx = None
          filtered = []
          for ln in lines:
            if min_idx is None and rx_min.match(ln):
              min_idx = len(filtered)
            if rx_ver.match(ln) or rx_tag.match(ln):
              continue
            filtered.append(ln)

          if min_idx is None:
            print("cmake_minimum_required line not found")
            sys.exit(1)

          insert_at = min_idx + 1
          while insert_at < len(filtered) and filtered[insert_at].strip() == "":
            insert_at += 1

          out = []
          out.extend(filtered[:min_idx + 1])
          if not filtered[min_idx].endswith("\n"):
            out.append("\n")
          out.append("\n")
          out.append(set_ver)
          out.append(set_tag)
          out.append("\n")
          out.extend(filtered[insert_at:])

          open(p, "w", encoding="utf-8", newline="").write("".join(out))

          chk = open(p, "r", encoding="utf-8").read()
          if f'set(VK_DYN_VER "{vk_ver}" CACHE STRING "vk-dynamic project version")' not in chk:
            print("Failed to set VK_DYN_VER")
            sys.exit(1)
          if f'set(VK_DYN_TAG "v{vk_ver}-{gl_ver}" CACHE STRING "vk-dynamic release tag")' not in chk:
            print("Failed to set VK_DYN_TAG")
            sys.exit(1)
          PY

      - name: If release branch exists, fix CMake variables on both default and release branch
        if: steps.branchcheck.outputs.exists == 'true'
        env:
          VK_VER: ${{ steps.plan.outputs.use_vk }}
          GL_VER: ${{ steps.plan.outputs.use_gl }}
        run: |
          set -euo pipefail

          default_branch="${{ steps.def.outputs.default_branch }}"
          release_ref="${{ steps.plan.outputs.release_ref }}"

          git checkout -B "$release_ref" "origin/$release_ref"
          python3 .github_update_cmake.py
          if git status --porcelain | grep -q .; then
            git add CMakeLists.txt
            git commit -m "Fix CMake version variables for ${release_ref}"
            git push origin "refs/heads/$release_ref:refs/heads/$release_ref"
          fi

          git checkout -B "$default_branch" "origin/$default_branch"
          python3 .github_update_cmake.py
          if git status --porcelain | grep -q .; then
            git add CMakeLists.txt
            git commit -m "Fix CMake version variables for ${release_ref}"
            git push origin "refs/heads/$default_branch:refs/heads/$default_branch"
          fi

      - name: Stop when release branch already exists
        if: steps.branchcheck.outputs.exists == 'true'
        run: |
          echo "Release branch already exists, only ensured CMake variables on both branches"

      - name: Checkout base for sync (default branch)
        if: steps.branchcheck.outputs.exists != 'true'
        run: |
          set -euo pipefail
          default_branch="${{ steps.def.outputs.default_branch }}"
          git checkout -B "$default_branch" "origin/$default_branch"

      - name: Vendor Vulkan-Headers include/vulkan and include/vk_video only
        if: steps.branchcheck.outputs.exists != 'true'
        run: |
          set -euo pipefail

          vk_tag="${{ steps.upstream.outputs.vk_tag }}"
          url="https://github.com/KhronosGroup/Vulkan-Headers/archive/refs/tags/${vk_tag}.tar.gz"

          tmp=$(mktemp -d)
          curl -L "$url" -o "$tmp/vkheaders.tgz"
          tar -xzf "$tmp/vkheaders.tgz" -C "$tmp"

          src_dir=$(find "$tmp" -maxdepth 1 -type d -name "Vulkan-Headers-*" | head -n 1)
          if [ -z "$src_dir" ]; then
            echo "Expected Vulkan-Headers source directory not found"
            exit 1
          fi

          if [ ! -d "$src_dir/include/vulkan" ] || [ ! -d "$src_dir/include/vk_video" ]; then
            echo "Expected include/vulkan or include/vk_video not found in Vulkan-Headers tarball"
            exit 1
          fi

          rm -rf include/vulkan include/vk_video
          mkdir -p include/vulkan include/vk_video

          rsync -a --delete "$src_dir/include/vulkan/" "include/vulkan/"
          rsync -a --delete "$src_dir/include/vk_video/" "include/vk_video/"

      - name: Vendor selected glslang subtree items only (Python, no bash loops)
        if: steps.branchcheck.outputs.exists != 'true'
        run: |
          set -euo pipefail

          gl_tag="${{ steps.upstream.outputs.gl_tag }}"
          url="https://github.com/KhronosGroup/glslang/archive/refs/tags/${gl_tag}.tar.gz"

          tmp="$(mktemp -d)"
          curl -L "$url" -o "$tmp/glslang.tgz"
          tar -xzf "$tmp/glslang.tgz" -C "$tmp"

          python3 - <<'PY'
          import os, shutil, sys, glob

          tmp = os.environ["TMPDIR"]
          candidates = [d for d in glob.glob(os.path.join(tmp, "glslang-*")) if os.path.isdir(d)]
          if not candidates:
            print("Expected glslang source directory not found")
            sys.exit(1)
          src_dir = sorted(candidates)[0]

          dirs_needed = [
            "CInterface",
            "ExtensionHeaders",
            "GenericCodeGen",
            "HLSL",
            "Include",
            "MachineIndependent",
            "OSDependent",
            "Public",
            "ResourceLimits",
          ]
          files_needed = ["CMakeLists.txt", "stub.cpp", "updateGrammar"]

          def is_base_ok(base: str) -> bool:
            for d in dirs_needed:
              if not os.path.isdir(os.path.join(base, d)):
                return False
            for f in files_needed:
              if not os.path.exists(os.path.join(base, f)):
                return False
            return True

          base = ""
          for c in [
            os.path.join(src_dir, "glslang", "glslang"),
            os.path.join(src_dir, "glslang"),
            src_dir,
          ]:
            if os.path.isdir(c) and is_base_ok(c):
              base = c
              break

          if not base:
            hits = glob.glob(os.path.join(src_dir, "**", "CInterface"), recursive=True)
            for h in hits:
              maybe = os.path.dirname(h)
              if is_base_ok(maybe):
                base = maybe
                break

          if not base:
            print("Could not locate glslang base directory containing the expected subtree")
            sys.exit(1)

          out_root = os.path.join(os.getcwd(), "include", "glslang", "glslang")
          if os.path.exists(out_root):
            shutil.rmtree(out_root)
          os.makedirs(out_root, exist_ok=True)

          for d in dirs_needed:
            shutil.copytree(os.path.join(base, d), os.path.join(out_root, d), dirs_exist_ok=True)

          for f in files_needed:
            shutil.copy2(os.path.join(base, f), os.path.join(out_root, f))
          PY
        env:
          TMPDIR: ${{ runner.temp }}

      - name: Update CMake version variables to match release
        if: steps.branchcheck.outputs.exists != 'true'
        env:
          VK_VER: ${{ steps.plan.outputs.use_vk }}
          GL_VER: ${{ steps.plan.outputs.use_gl }}
        run: |
          set -euo pipefail
          python3 .github_update_cmake.py

      - name: Reapply local patches if present
        if: steps.branchcheck.outputs.exists != 'true'
        run: |
          set -euo pipefail
          if ls patches/*.patch >/dev/null 2>&1; then
            git am --3way patches/*.patch
          else
            echo "No patches found, skipping"
          fi

      - name: Commit and push changes to default branch
        if: steps.branchcheck.outputs.exists != 'true'
        run: |
          set -euo pipefail

          default_branch="${{ steps.def.outputs.default_branch }}"
          vk_tag="${{ steps.upstream.outputs.vk_tag }}"
          gl_tag="${{ steps.upstream.outputs.gl_tag }}"

          if git status --porcelain | grep -q .; then
            git add -A
            git commit -m "Sync Vulkan-Headers ${vk_tag} and glslang ${gl_tag}"
            git push origin "refs/heads/$default_branch:refs/heads/$default_branch"
          else
            echo "No changes to commit on default branch"
          fi

      - name: Create release branch at default branch HEAD and push
        if: steps.branchcheck.outputs.exists != 'true'
        run: |
          set -euo pipefail
          release_ref="${{ steps.plan.outputs.release_ref }}"
          git branch -f "$release_ref" HEAD
          git push -f origin "refs/heads/$release_ref:refs/heads/$release_ref"

      - name: Create tag and GitHub Release vVK-GL
        if: steps.branchcheck.outputs.exists != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          release_ref="${{ steps.plan.outputs.release_ref }}"
          vk_tag="${{ steps.upstream.outputs.vk_tag }}"
          gl_tag="${{ steps.upstream.outputs.gl_tag }}"
          last_tag="${{ steps.local.outputs.last_tag }}"

          vk_url="https://github.com/KhronosGroup/Vulkan-Headers/releases/tag/${vk_tag}"
          gl_url="https://github.com/KhronosGroup/glslang/releases/tag/${gl_tag}"

          printf "%s\n" \
            "Automated vendor sync to upstream releases." \
            "" \
            "Previous local release: ${last_tag}" \
            "" \
            "Upstream Vulkan-Headers: ${vk_tag}" \
            "${vk_url}" \
            "" \
            "Upstream glslang: ${gl_tag}" \
            "${gl_url}" \
            "" \
            "Release ref: ${release_ref}" \
            > release_notes.txt

          if ! git show-ref --verify --quiet "refs/tags/$release_ref"; then
            git tag -a "$release_ref" -m "Sync to Vulkan-Headers ${vk_tag} and glslang ${gl_tag}"
            git push origin "refs/tags/$release_ref:refs/tags/$release_ref"
          fi

          if gh release view "$release_ref" >/dev/null 2>&1; then
            echo "Release already exists"
            exit 0
          fi

          gh release create "$release_ref" \
            --title "Vulkan-Headers ${vk_tag} and glslang ${gl_tag}" \
            --notes-file release_notes.txt